<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imagen Deformada por Aut√≥matas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 11px;
            color: #ccc;
        }
        
        input[type="range"] {
            width: 140px;
            height: 4px;
            background: #333;
            border-radius: 2px;
        }
        
        button {
            background: linear-gradient(45deg, #333, #555);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            margin: 2px;
            font-size: 11px;
        }
        
        button:hover {
            background: linear-gradient(45deg, #555, #777);
        }
        
        #video {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            transform: scaleX(-1);
            opacity: 0.8;
        }
        
        #status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #fff;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 6px;
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <video id="video" autoplay muted></video>
        
        <div id="controls">
            <div class="control-group">
                <label>üî• Intensidad de Degradaci√≥n:</label>
                <input type="range" id="degradation" min="0.1" max="0.95" step="0.05" value="0.7">
            </div>
            <div class="control-group">
                <label>‚ö° Velocidad de Flujo:</label>
                <input type="range" id="flowSpeed" min="0.5" max="5.0" step="0.1" value="2.0">
            </div>
            <div class="control-group">
                <label>üåä Fuerza de Deformaci√≥n:</label>
                <input type="range" id="distortion" min="0.0" max="20.0" step="0.5" value="5.0">
            </div>
            <div class="control-group">
                <label>üé® Mezcla de Color:</label>
                <input type="range" id="colorMix" min="0.0" max="1.0" step="0.1" value="0.6">
            </div>
            <div class="control-group">
                <label>üìê Resoluci√≥n Celular:</label>
                <input type="range" id="resolution" min="0.5" max="4.0" step="0.1" value="1.5">
            </div>
            <div class="control-group">
                <button id="reset">üîÑ Reset</button>
                <button id="pause">‚è∏Ô∏è Pausar</button>
            </div>
        </div>
        
        <div id="status">
            Iniciando degradaci√≥n digital...
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        const video = document.getElementById('video');
        const status = document.getElementById('status');
        
        // Verificar WebGL
        if (!gl) {
            status.textContent = 'Error: WebGL no est√° disponible en este navegador';
            console.error('WebGL no disponible');
        }
        
        // Controles
        const degradationSlider = document.getElementById('degradation');
        const flowSpeedSlider = document.getElementById('flowSpeed');
        const distortionSlider = document.getElementById('distortion');
        const colorMixSlider = document.getElementById('colorMix');
        const resolutionSlider = document.getElementById('resolution');
        const resetBtn = document.getElementById('reset');
        const pauseBtn = document.getElementById('pause');
        
        let isRunning = true;
        let frameCount = 0;
        
        // Configurar canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gl) {
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_texCoord;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = (a_position + 1.0) * 0.5;
            }
        `;
        
        // Fragment shader para deformaci√≥n fluida por aut√≥matas
        const fragmentShaderSource = `
            precision mediump float;
            
            uniform sampler2D u_previousFrame;
            uniform sampler2D u_videoTexture;
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_degradation;
            uniform float u_flowSpeed;
            uniform float u_distortion;
            uniform float u_colorMix;
            uniform float u_cellResolution;
            
            varying vec2 v_texCoord;
            
            // Funci√≥n de ruido mejorada
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            
            // Ruido suave
            float smoothNoise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                
                float a = noise(i);
                float b = noise(i + vec2(1.0, 0.0));
                float c = noise(i + vec2(0.0, 1.0));
                float d = noise(i + vec2(1.0, 1.0));
                
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }
            
            // Aut√≥mata celular para deformaci√≥n
            float cellularPattern(vec2 coord, float time) {
                vec2 cellCoord = floor(coord * u_cellResolution) / u_cellResolution;
                
                float n1 = smoothNoise(cellCoord * 10.0 + time * u_flowSpeed);
                float n2 = smoothNoise(cellCoord * 20.0 - time * u_flowSpeed * 0.7);
                float n3 = smoothNoise(cellCoord * 5.0 + time * u_flowSpeed * 1.3);
                
                // Crear patr√≥n celular evolutivo
                float pattern = sin(n1 * 6.28) * cos(n2 * 6.28) * sin(n3 * 3.14);
                
                // Aut√≥mata que se propaga
                float wave1 = sin((coord.x + coord.y) * 15.0 + time * u_flowSpeed * 3.0);
                float wave2 = cos((coord.x - coord.y) * 12.0 - time * u_flowSpeed * 2.0);
                
                return (pattern + wave1 * 0.3 + wave2 * 0.2) * 0.5 + 0.5;
            }
            
            void main() {
                vec2 coord = v_texCoord;
                
                // Crear deformaci√≥n basada en aut√≥matas celulares
                float cellPattern = cellularPattern(coord, u_time);
                float cellPattern2 = cellularPattern(coord + vec2(0.1, 0.15), u_time + 1.0);
                
                // Deformaci√≥n de coordenadas
                vec2 distortionForce = vec2(
                    (cellPattern - 0.5) * u_distortion / u_resolution.x,
                    (cellPattern2 - 0.5) * u_distortion / u_resolution.y
                );
                
                // Coordenadas deformadas para la c√°mara
                vec2 videoCoord = vec2(1.0 - coord.x, coord.y) + distortionForce;
                videoCoord = clamp(videoCoord, 0.0, 1.0);
                
                // Obtener imagen de la c√°mara deformada
                vec3 cameraColor = texture2D(u_videoTexture, videoCoord).rgb;
                
                // Obtener frame anterior para crear persistencia/degradaci√≥n
                vec3 previousColor = texture2D(u_previousFrame, coord + distortionForce * 0.5).rgb;
                
                // Crear efecto de degradaci√≥n celular
                float degradationMask = cellularPattern(coord + u_time * 0.1, u_time * 2.0);
                float degradationAmount = u_degradation + degradationMask * 0.2;
                
                // Mezclar frame anterior con nueva imagen (efecto de persistencia/decaimiento)
                vec3 persistentColor = mix(cameraColor, previousColor, degradationAmount);
                
                // Crear colores de aut√≥mata
                float cellIntensity = cellPattern;
                vec3 cellColor = vec3(
                    0.1 + cellIntensity * 0.4,
                    0.6 + sin(cellIntensity * 3.14 + u_time) * 0.3,
                    0.3 + cos(cellIntensity * 6.28 + u_time * 1.5) * 0.4
                );
                
                // Mezclar colores originales con colores celulares
                vec3 finalColor = mix(persistentColor, cellColor, u_colorMix * cellIntensity);
                
                // A√±adir efectos de corrupci√≥n digital
                float corruption = smoothNoise(coord * 50.0 + u_time * 5.0);
                if (corruption > 0.8) {
                    finalColor = mix(finalColor, vec3(1.0, 0.2, 0.8), 0.3);
                }
                
                // Efecto de escanlines din√°mico
                float scanline = sin(coord.y * u_resolution.y * 0.5 + u_time * 10.0) * 0.1 + 0.9;
                finalColor *= scanline;
                
                // Vignette sutil
                float vignette = 1.0 - length(coord - 0.5) * 0.8;
                finalColor *= vignette;
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        // Compilar shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error compilando shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        // Crear programa de shader
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Error enlazando programa:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }
        
        // Variables globales para WebGL
        let program = null;
        let positionBuffer = null;
        let positionAttributeLocation = null;
        let previousFrameLocation = null;
        let videoTextureLocation = null;
        let resolutionLocation = null;
        let timeLocation = null;
        let degradationLocation = null;
        let flowSpeedLocation = null;
        let distortionLocation = null;
        let colorMixLocation = null;
        let cellResolutionLocation = null;
        
        // Configurar WebGL
        function initWebGL() {
            if (!gl) return false;
            
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            if (!vertexShader || !fragmentShader) {
                status.textContent = 'Error: No se pudieron compilar los shaders';
                return false;
            }
            
            program = createProgram(gl, vertexShader, fragmentShader);
            
            if (!program) {
                status.textContent = 'Error: No se pudo crear el programa WebGL';
                return false;
            }
            
            // Configurar buffers
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,  1, -1, -1,  1,
                -1,  1,  1, -1,  1,  1
            ]), gl.STATIC_DRAW);
            
            // Obtener ubicaciones de atributos y uniforms
            positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
            previousFrameLocation = gl.getUniformLocation(program, 'u_previousFrame');
            videoTextureLocation = gl.getUniformLocation(program, 'u_videoTexture');
            resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            timeLocation = gl.getUniformLocation(program, 'u_time');
            degradationLocation = gl.getUniformLocation(program, 'u_degradation');
            flowSpeedLocation = gl.getUniformLocation(program, 'u_flowSpeed');
            distortionLocation = gl.getUniformLocation(program, 'u_distortion');
            colorMixLocation = gl.getUniformLocation(program, 'u_colorMix');
            cellResolutionLocation = gl.getUniformLocation(program, 'u_cellResolution');
            
            return true;
        }
        
        // Crear texturas
        const frameTexture1 = gl ? gl.createTexture() : null;
        const frameTexture2 = gl ? gl.createTexture() : null;
        const videoTexture = gl ? gl.createTexture() : null;
        
        let currentFrameTexture = frameTexture1;
        let previousFrameTexture = frameTexture2;
        
        // Configurar texturas
        function setupTexture(texture, width, height, data = null) {
            if (!gl || !texture) return;
            
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        
        // Inicializar texturas
        function initializeTextures() {
            if (!gl) return;
            
            setupTexture(frameTexture1, canvas.width, canvas.height);
            setupTexture(frameTexture2, canvas.width, canvas.height);
            setupTexture(videoTexture, 640, 480);
        }
        
        // Configurar c√°mara
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480, frameRate: 30 } 
                });
                video.srcObject = stream;
                
                video.addEventListener('loadedmetadata', () => {
                    status.textContent = 'üî• Degradaci√≥n activa - Tu imagen se deforma constantemente';
                    initializeTextures();
                });
                
            } catch (err) {
                status.textContent = 'Error: No se pudo acceder a la c√°mara';
                console.error('Error accediendo a la c√°mara:', err);
            }
        }
        
        // Framebuffer para renderizado off-screen
        const framebuffer = gl ? gl.createFramebuffer() : null;
        
        let startTime = Date.now();
        
        function render() {
            const currentTime = (Date.now() - startTime) / 1000;
            frameCount++;
            
            if (!isRunning || !gl || !program) {
                requestAnimationFrame(render);
                return;
            }
            
            // Actualizar textura de video
            if (video.readyState >= 2) {
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, videoTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            }
            
            // Renderizar a textura off-screen
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, currentFrameTexture, 0);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.useProgram(program);
            
            // Configurar atributos
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Configurar uniforms
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, previousFrameTexture);
            gl.uniform1i(previousFrameLocation, 0);
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, videoTexture);
            gl.uniform1i(videoTextureLocation, 1);
            
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, currentTime);
            gl.uniform1f(degradationLocation, parseFloat(degradationSlider.value));
            gl.uniform1f(flowSpeedLocation, parseFloat(flowSpeedSlider.value));
            gl.uniform1f(distortionLocation, parseFloat(distortionSlider.value));
            gl.uniform1f(colorMixLocation, parseFloat(colorMixSlider.value));
            gl.uniform1f(cellResolutionLocation, parseFloat(resolutionSlider.value));
            
            // Dibujar
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Renderizar a pantalla
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, currentFrameTexture);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // Intercambiar texturas para el pr√≥ximo frame
            let temp = currentFrameTexture;
            currentFrameTexture = previousFrameTexture;
            previousFrameTexture = temp;
            
            requestAnimationFrame(render);
        }
        
        // Event listeners
        resetBtn.addEventListener('click', () => {
            initializeTextures();
            startTime = Date.now();
        });
        
        pauseBtn.addEventListener('click', () => {
            isRunning = !isRunning;
            pauseBtn.innerHTML = isRunning ? '‚è∏Ô∏è Pausar' : '‚ñ∂Ô∏è Reanudar';
        });
        
        // Inicializar todo
        if (initWebGL()) {
            setupCamera();
            render();
        } else {
            status.textContent = 'Error: WebGL no se pudo inicializar';
        }
        
    </script>}

</body>
</html>
