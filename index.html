<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autómatas Celulares con Cámara Integrada</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 150px;
        }
        
        button {
            background: #333;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
        }
        
        button:hover {
            background: #555;
        }
        
        #video {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #fff;
            border-radius: 5px;
            transform: scaleX(-1);
        }
        
        #status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #fff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <video id="video" autoplay muted></video>
        
        <div id="controls">
            <div class="control-group">
                <label>Velocidad de Evolución:</label>
                <input type="range" id="speed" min="1" max="60" step="1" value="30">
            </div>
            <div class="control-group">
                <label>Mezcla Cámara/Autómata:</label>
                <input type="range" id="blend" min="0.0" max="1.0" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label>Umbral de Brillo:</label>
                <input type="range" id="threshold" min="0.1" max="0.9" step="0.1" value="0.4">
            </div>
            <div class="control-group">
                <label>Tamaño de Célula:</label>
                <input type="range" id="cellSize" min="1" max="8" step="1" value="3">
            </div>
            <div class="control-group">
                <button id="pause">Pausar</button>
            </div>
        </div>
        
        <div id="status">
            Inicializando cámara...
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        const video = document.getElementById('video');
        const status = document.getElementById('status');
        
        // Controles
        const speedSlider = document.getElementById('speed');
        const blendSlider = document.getElementById('blend');
        const thresholdSlider = document.getElementById('threshold');
        const cellSizeSlider = document.getElementById('cellSize');
        const pauseBtn = document.getElementById('pause');
        
        let isRunning = true;
        let frameCount = 0;
        
        // Configurar canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_texCoord;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = (a_position + 1.0) * 0.5;
            }
        `;
        
        // Fragment shader que integra cámara con autómatas
        const fragmentShaderSource = `
            precision mediump float;
            
            uniform sampler2D u_currentState;
            uniform sampler2D u_videoTexture;
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_blend;
            uniform float u_threshold;
            uniform float u_cellSize;
            
            varying vec2 v_texCoord;
            
            // Función para obtener el estado de una célula vecina
            float getCell(vec2 offset) {
                vec2 cellOffset = offset * u_cellSize;
                vec2 coord = v_texCoord + cellOffset / u_resolution;
                if (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0) {
                    return 0.0;
                }
                return texture2D(u_currentState, coord).r;
            }
            
            // Convertir píxel de cámara a estado celular
            float getCameraCell() {
                vec2 videoCoord = vec2(1.0 - v_texCoord.x, v_texCoord.y);
                vec3 cameraColor = texture2D(u_videoTexture, videoCoord).rgb;
                float brightness = dot(cameraColor, vec3(0.299, 0.587, 0.114));
                return step(u_threshold, brightness);
            }
            
            void main() {
                // Obtener coordenadas de célula
                vec2 cellCoord = floor(v_texCoord * u_resolution / u_cellSize) * u_cellSize / u_resolution;
                
                // Contar vecinos vivos
                float neighbors = 
                    getCell(vec2(-1, -1)) + getCell(vec2(0, -1)) + getCell(vec2(1, -1)) +
                    getCell(vec2(-1,  0)) +                        getCell(vec2(1,  0)) +
                    getCell(vec2(-1,  1)) + getCell(vec2(0,  1)) + getCell(vec2(1,  1));
                
                float currentCell = getCell(vec2(0, 0));
                float cameraCell = getCameraCell();
                
                // Autómata celular híbrido
                float automataState = 0.0;
                
                // Reglas modificadas que consideran tanto vecinos como cámara
                if (currentCell > 0.5 || cameraCell > 0.5) {
                    // Célula viva o píxel brillante de cámara
                    if (neighbors >= 2.0 && neighbors <= 3.0) {
                        automataState = 1.0;
                    } else if (neighbors == 1.0 && cameraCell > 0.5) {
                        // La cámara puede "rescatar" células con pocos vecinos
                        automataState = 1.0;
                    }
                } else {
                    // Célula muerta
                    if (neighbors >= 2.8 && neighbors <= 3.2) {
                        automataState = 1.0;
                    }
                }
                
                // Mezclar estado del autómata con imagen de cámara
                vec2 videoCoord = vec2(1.0 - v_texCoord.x, v_texCoord.y);
                vec3 cameraColor = texture2D(u_videoTexture, videoCoord).rgb;
                
                // Estado final basado en mezcla
                float finalState = mix(automataState, cameraCell, u_blend);
                
                // Colores dinámicos
                vec3 finalColor;
                if (finalState > 0.5) {
                    // Combinar colores de cámara con colores de autómata
                    vec3 automataColor = vec3(0.2, 1.0, 0.5); // Verde característico
                    finalColor = mix(automataColor, cameraColor, u_blend);
                    
                    // Efecto de "vida digital"
                    float pulse = sin(u_time * 3.0 + v_texCoord.x * 10.0 + v_texCoord.y * 10.0) * 0.1 + 0.9;
                    finalColor *= pulse;
                } else {
                    // Fondo con trazas de la cámara
                    finalColor = cameraColor * 0.1 * (1.0 - u_blend);
                }
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        // Compilar shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error compilando shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        // Crear programa de shader
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Error enlazando programa:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }
        
        // Configurar WebGL
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);
        
        // Configurar buffers
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1, -1,  1,
            -1,  1,  1, -1,  1,  1
        ]), gl.STATIC_DRAW);
        
        // Obtener ubicaciones de atributos y uniforms
        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        const currentStateLocation = gl.getUniformLocation(program, 'u_currentState');
        const videoTextureLocation = gl.getUniformLocation(program, 'u_videoTexture');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const blendLocation = gl.getUniformLocation(program, 'u_blend');
        const thresholdLocation = gl.getUniformLocation(program, 'u_threshold');
        const cellSizeLocation = gl.getUniformLocation(program, 'u_cellSize');
        
        // Crear texturas para el estado actual y siguiente
        const currentStateTexture = gl.createTexture();
        const nextStateTexture = gl.createTexture();
        const videoTexture = gl.createTexture();
        
        // Configurar texturas
        function setupTexture(texture, width, height, data = null) {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        
        // Inicializar estado basado en la cámara
        function initializeFromCamera() {
            const width = canvas.width;
            const height = canvas.height;
            const data = new Uint8Array(width * height * 4);
            
            // Inicializar con patrón aleatorio que será reemplazado por la cámara
            for (let i = 0; i < data.length; i += 4) {
                const alive = Math.random() < 0.1 ? 255 : 0;
                data[i] = alive;     // R
                data[i + 1] = alive; // G
                data[i + 2] = alive; // B
                data[i + 3] = 255;   // A
            }
            
            setupTexture(currentStateTexture, width, height, data);
            setupTexture(nextStateTexture, width, height);
        }
        
        // Configurar cámara
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 } 
                });
                video.srcObject = stream;
                
                video.addEventListener('loadedmetadata', () => {
                    status.textContent = 'Cámara integrada - Los píxeles son células vivas';
                    setupTexture(videoTexture, video.videoWidth, video.videoHeight);
                });
                
            } catch (err) {
                status.textContent = 'Error: No se pudo acceder a la cámara';
                console.error('Error accediendo a la cámara:', err);
            }
        }
        
        // Framebuffer para renderizado off-screen
        const framebuffer = gl.createFramebuffer();
        
        let startTime = Date.now();
        
        function render() {
            if (!isRunning) return;
            
            const currentTime = (Date.now() - startTime) / 1000;
            frameCount++;
            
            // Actualizar textura de video constantemente
            if (video.readyState >= 2) {
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, videoTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            }
            
            // Solo evolucionar el autómata según la velocidad seleccionada
            if (frameCount % Math.max(1, 61 - parseInt(speedSlider.value)) === 0) {
                // Renderizar a textura off-screen (próximo estado)
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, nextStateTexture, 0);
                gl.viewport(0, 0, canvas.width, canvas.height);
                
                gl.useProgram(program);
                
                // Configurar atributos
                gl.enableVertexAttribArray(positionAttributeLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Configurar uniforms
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, currentStateTexture);
                gl.uniform1i(currentStateLocation, 0);
                
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, videoTexture);
                gl.uniform1i(videoTextureLocation, 1);
                
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                gl.uniform1f(timeLocation, currentTime);
                gl.uniform1f(blendLocation, parseFloat(blendSlider.value));
                gl.uniform1f(thresholdLocation, parseFloat(thresholdSlider.value));
                gl.uniform1f(cellSizeLocation, parseFloat(cellSizeSlider.value));
                
                // Dibujar
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Intercambiar texturas
                const temp = currentStateTexture;
                currentStateTexture = nextStateTexture;
                nextStateTexture = temp;
            }
            
            // Renderizar a pantalla siempre
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, currentStateTexture);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            requestAnimationFrame(render);
        }
        
        // Event listeners
        pauseBtn.addEventListener('click', () => {
            isRunning = !isRunning;
            pauseBtn.textContent = isRunning ? 'Pausar' : 'Reanudar';
            if (isRunning) render();
        });
        
        // Inicializar
        setupCamera();
        initializeFromCamera();
        render();
        
    </script>
</body>
</html>
